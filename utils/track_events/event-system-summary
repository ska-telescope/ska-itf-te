#!/usr/bin/env python

from tango import DeviceProxy, DevFailed
from argparse import ArgumentParser
import re
import json
import statistics
import itertools
import time

def build_parser() -> ArgumentParser:
    parser = ArgumentParser(
        prog="event-system-summarizer",
        description="Called QueryEventSystem periodically and summarizes the output",
    )
    parser.add_argument('device', help='device or admin device to connect to')
    parser.add_argument('--poll-period', help='period between polls in seconds', type=float, default=10.0)

    return parser

regex = re.compile("tango://[^/]+/(.*)")
def strl(ev):
    m = regex.match(ev)
    return m.group(1)

def print_stats(sorted_array, name, units=' (μs)'):
    mean = float(statistics.mean(sorted_array))
    stdev = float(statistics.pstdev(sorted_array))
    err = stdev / (len(sorted_array) ** 0.5)
    minimum = min(sorted_array)
    maximum = max(sorted_array)
    try:
        pc10 = sorted_array[len(sorted_array) // 10]
        pc90 = sorted_array[len(sorted_array) - len(sorted_array) // 10]
    except:
        pc10 = None
        pc90 = None
    name = name + units;
    print(f"\t{name:>30}: {mean:10.2f}±{err:<10.2f} (min={minimum}, 10%={pc10}, 90%={pc90} max={maximum})")

def print_summary(data, last_data):
    server = data['server']
    counters = server['event_counters']
    last_counters = last_data['server']['event_counters'] if last_data is not None else {}
    event_names = set(itertools.chain(counters.keys(), last_counters.keys()))
    new = []
    removed = []
    changed = []
    for ev in event_names:
        if ev in counters and ev not in last_counters:
            new.append(ev)
        elif ev in last_counters and ev not in counters:
            removed.append(ev)
        elif counters[ev] != last_counters[ev]:
            changed.append(ev)

    if len(new) > 0:
        print("New publishers:")
        for ev in new:
            print(f"\t{strl(ev)}: {counters[ev]}")

    if len(changed) > 0:
        print("Published events:")
        for ev in changed:
            print(f"\t{strl(ev)}: {counters[ev] - last_counters[ev]:+}")

    if len(removed) > 0:
        print("Removed publishers:")
        for ev in removed:
            print(f"\t{strl(ev)}")

    if server['perf_stats'] is not None and len(server['perf_stats']) > 0:
        print('Publishing performance:')
        stats = server['perf_stats']
        micros_since_last_events = sorted(x["micros_since_last_event"] for x in stats if x["micros_since_last_event"] != -1)
        print_stats(micros_since_last_events, "Event Gaps")
        push_event_micros = sorted(x["push_event_micros"] for x in stats)
        print_stats(push_event_micros, "Event push time")

    if 'client' in data:
        client = data['client']
        callbacks = client['event_callbacks']
        last_callbacks = last_data['client']['event_callbacks'] if last_data is not None and 'client' in last_data else {}
        event_names = set(itertools.chain(callbacks.keys(), last_callbacks.keys()))
        new = []
        removed = []
        changed = []
        for ev in event_names:
            if ev in callbacks and ev not in last_callbacks:
                new.append(ev)
            elif ev in last_callbacks and ev not in callbacks:
                removed.append(ev)
            elif callbacks[ev]["counter"] != last_callbacks[ev]["counter"] or \
                callbacks[ev]["callback_count"] != last_callbacks[ev]["callback_count"]:
                changed.append(ev)

        if len(new) > 0:
            print("New subscriptions:")
            for ev in new:
                v = callbacks[ev]
                print(f'\t{strl(ev)}: {v["counter"]} ({v["callback_count"]} callback(s) registered)')

        if len(changed) > 0:
            print("Received events or callbacks changed:")
            for ev in changed:
                v = callbacks[ev]
                last = last_callbacks[ev]
                print(f'\t{strl(ev)}: {v["counter"] - last["counter"]:+} ({v["callback_count"] - last["callback_count"]:+} callbacks)')

        if len(removed) > 0:
            print("Removed subscriptions:")
            for ev in removed:
                print(f"\t{strl(ev)}")

        if client['perf_stats'] is not None and len(client['perf_stats']) > 0:
            stats = client['perf_stats']
            print('Subscription performance:')
            micros_since_last_events = sorted(x["micros_since_last_event"] for x in stats if x["micros_since_last_event"] != -1)
            print_stats(micros_since_last_events, "Event Gaps")
            sleep_micros = sorted(x["sleep_micros"] for x in stats)
            print_stats(sleep_micros, "Sleeping time")
            process_micros = sorted(x["process_micros"] for x in stats)
            print_stats(process_micros, "Processing time")
            first_callback_latency = sorted(x["first_callback_lactency_micros"] for x in stats if x["first_callback_lactency_micros"] != -9223372036854775808)
            print_stats(first_callback_latency, "First callback latency")
            callback_count = sorted(x["callback_count"] for x in stats)
            print_stats(callback_count, "Callback Count")
            wake_count = sorted(x["wake_count"] for x in stats)
            print_stats(wake_count, "Wake Count")

def main(args: dict):
    name = args.device
    display_name = name
    dp = DeviceProxy(name)

    if dp.info().dev_class != 'DServer':
        adm_name = dp.adm_name()
        display_name = f'{adm_name} (from {name})'
        name = adm_name
        dp = DeviceProxy(name)

    if 'QueryEventSystem' not in dp.get_command_list():
        print(f'{display_name} does not support QueryEventSystem, is this pod using "PyTango 9.5.1234"?', file=sys.stderr)
        sys.exit(1)

    last_data = None
    while(True):
        next_poll = time.time() + args.poll_period

        try:
            data = json.loads(dp.QueryEventSystem())
            print_summary(data, last_data)
            last_data = data;
        except DevFailed as exc:
            print(exc, file=sys.stderr)

        sleep_for = next_poll - time.time()
        if sleep_for > 0.001:
            time.sleep(sleep_for)
        elif sleep_for < 0:
            print(f'poll time missed by {-sleep_for}s', file=sys.stderr)


if __name__ == '__main__':
    args = build_parser().parse_args()
    main(args)
